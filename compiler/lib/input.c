//
// Created by Mookel on 16/9/1.
// Email : ltp0709@sina.com 
// Copyright (c) 2016 jlu.edu. All rights reserved.
// input.c : The input system used by cglex analyzers.
//

#include <debug.h>
#include <fcntl.h>
#include <unistd.h>
#include <input.h>
#include <string.h>
#include <syslib.h>
#include <com.h>

/*private macro definitions. */
#define _STDIN             0
#define _MAX_LOOKAHEAD    16    /*maximum amount of lookahead*/
#define _MAX_LEXEME_LEN   1024  /*maximum lexeme sizes.*/
#define _BUFSIZE          ((_MAX_LEXEME_LEN * 3) + (2 *_MAX_LOOKAHEAD))

#define _DANGER           (_end_buf - _MAX_LOOKAHEAD)
#define _END              (&_start_buf[_BUFSIZE])
#define _NO_MORE_CHARS()  (_eof_read && (_next >= _end_buf))

#define _MCOPY(d, s, len) memmove((d), (s), (len))

/*static variables definitions*/
typedef unsigned char uchar;

PRIVATE uchar _start_buf[_BUFSIZE];    /*input buffer*/
PRIVATE uchar *_end_buf = _END;        /*just past the last character.*/
PRIVATE uchar *_next = _END;           /*next input character*/
PRIVATE uchar *_smark = _END;          /*start of current lexeme*/
PRIVATE uchar *_emark = _END;          /*end of current lexeme*/
PRIVATE uchar *_pmark = NULL;          /*start of previous lexeme*/
PRIVATE int   _plineno = 0;            /*line # of previous lexeme*/
PRIVATE int   _plength = 0;            /*length of previous lexeme*/

PRIVATE int   _input_file = _STDIN;    /*input file handle*/
PRIVATE int   _lineno = 1;             /*current line number*/
PRIVATE int   _mline = 1;              /*line number when mark_end called.*/
PRIVATE int   _termchar = 0;           /*holds the character that was overwritten by \0
                                       when we null terminated the last lexme.*/
PRIVATE int   _eof_read = 0;           /*end of file has been read. note that it doesn't
                                       mean there is not character in input buffer.*/

PRIVATE fp_ii_open_t _fp_open = (fp_ii_open_t) open;
PRIVATE fp_ii_close_t _fp_close = (fp_ii_close_t) close;
PRIVATE fp_ii_read_t _fp_read = (fp_ii_read_t) read;

/*global functions definitions*/
PUBLIC void ii_io(fp_ii_open_t fp_open, fp_ii_close_t fp_close, fp_ii_read_t fp_read)
{
    _fp_open = fp_open;
    _fp_close = fp_close;
    _fp_read = fp_read;
}

/**
 * Prepare a new input file for reading.If newfile isn't called before input() or input_line
 * then stdin is used. The current input file is closed after successfully opening the new one.
 *
 * return -1 if the file cant't be opened; otherwise return the file descriptor return from
 * open(); Note that the old input file won't be closed unless the new file is opened successfully.
 * The errno generated by the bad open() will still be valid, so you can call perror() to find out
 * what went wrong. At least one free file descriptor must be available when newfile() is called.
 */
PUBLIC int ii_newfile(char *name)
{
    int fd;

    if((fd = !name ? _STDIN : (*_fp_open)(name , O_RDONLY | O_BINARY)) != -1){
        if(_input_file != _STDIN){
            (*_fp_close)(_input_file);
        }

        _input_file = fd;
        _eof_read   = 0;
        _next       = _END;
        _smark      = _END;
        _pmark      = NULL;
        _emark      = _END;
        _end_buf    = _END;
        _lineno     = 1;
        _mline      = 1;
    }

    return fd;
}

PUBLIC unsigned char *ii_text(void) { return _smark; }

PUBLIC int ii_length(void) { return (int)(_emark - _smark); }

PUBLIC int ii_lineno(void) { return _lineno; }

PUBLIC unsigned char *ii_ptext(void) { return _pmark;}

PUBLIC int ii_plength(void) { return _plength;}

PUBLIC int ii_plineno(void) { return _plineno;}

PUBLIC unsigned char *ii_mark_start(void)
{
    _mline = _lineno;  /*why remember lineno here ?*/
    _emark = _smark = _next;
    return _smark;
}

PUBLIC unsigned char *ii_mark_end(void)
{
    _mline = _lineno;  /*when lookhead has come to a failure status, we can reback*/
    return _emark = _next;

}

PUBLIC unsigned char *ii_move_start(void)
{
    if(_smark >= _emark) { return NULL;}
    else {return ++_smark;}
}

PUBLIC unsigned char *ii_move_back(void)
{
    _lineno = _mline;
    return _next = _emark;
}

PUBLIC unsigned char *ii_mark_prev(void)
{
    _plineno = _lineno;
    _plength = _emark - _smark;
    return _pmark = _smark;
}

PUBLIC int ii_advance(void)
{
    static int been_called = 0;
    if(!been_called) {
        /*push a new line into the empty buffer*/
        _next = _smark = _emark = _END - 1;
        _pmark = NULL;
        *_next = '\n';
        --_lineno;
        --_mline;
        been_called = 1;
    }

    if(_NO_MORE_CHARS()) return 0;
    if(!_eof_read && (ii_flush(0) < 0)) return -1;

    if(*_next == '\n') ++_lineno;

    return (*_next++);
}

/* Flush the input buffer. Do nothing if the current input character isn't
 * in the danger zone, otherwise move all unread characters to the left end
 * of the buffer and fill the remainder of the buffer. Note that input()
 * flushes the buffer willy-nilly if you read past the end of buffer.
 * Similarly, input_line() flushes the buffer at the beginning of each line.
 *
 *				       pMark	DANGER
 *				        |   	   |
 *	    Start_buf		       sMark eMark |Next  End_buf
 *		|			||     |   ||	  |
 *		V			VV     V   VV	  V
 *		+-----------------------+----------------+-------+
 *		| this is already read  | to be done yet | waste |
 *		+-----------------------+----------------+-------+
 *		|			|		 |       |
 *		|<----- shift_amt ----->|<-- copy_amt -->|       |
 *		|			 		         |
 *		|<------------------ BUFSIZE ------------------->|
 *
 * Either the pMark or sMark (whichever is smaller) is used as the leftmost
 * edge of the buffer. None of the text to the right of the mark will be
 * lost. Return 1 if everything's ok, -1 if the buffer is so full that it
 * can't be flushed. 0 if we're at end of file. If "force" is true, a buffer
 * flush is forced and the characters already in it are discarded. Don't
 * call this function on a buffer that's been terminated by ii_term().
 */
PUBLIC int ii_flush(int force)
{
    int copy_amt, shift_amt;
    uchar *left_edge;

    if(_NO_MORE_CHARS()) { return 0; }

    if(_eof_read) { return 1; }

    if(_next >= _DANGER || force) {
        left_edge = _pmark  ? min(_smark, _pmark) : _smark;
        shift_amt = (int)(left_edge - _start_buf);

        if(shift_amt < _MAX_LEXEME_LEN) { /*not enough room.*/
            if(!force) { return -1;}

            left_edge = ii_mark_start(); /*reset start to current character*/
            ii_mark_prev();

            shift_amt = (int)(left_edge - _start_buf);
        }

        copy_amt = (int)(_end_buf - left_edge);
        _MCOPY(_start_buf, left_edge, copy_amt);

        if(!ii_fillbuf(_start_buf + copy_amt)) {
            com_ferr("INTERNAL_ERROR, ii_flush: Buffer full, can't read.\n");
        }

        if(_pmark){_pmark -= shift_amt;}

        _smark -= shift_amt;
        _emark -= shift_amt;
        _next  -= shift_amt;
    }

    return 1;
}

PUBLIC int ii_fillbuf(unsigned char *starting_at)
{
    int need, got;

    need = ((int)(_END - starting_at) / _MAX_LEXEME_LEN) *_MAX_LEXEME_LEN;
    D(printf("Reading %d bytes.\n", need);)

    if(need < 0){
        com_ferr("INTER ERROR ii_fillbuf: Bad read request starting addr.\n");
    }

    if(need == 0) {return 0;}

    if((got = (*_fp_read)(_input_file, starting_at, need)) == -1){
        com_ferr("INTER ERROR ii_fillbuf: can not read input file.");
    }

    _end_buf = starting_at + got;
    if(got < need) _eof_read = 1;

    return got;
}

PUBLIC int ii_look(int n)
{
    if(n > (_end_buf - _next)) { return _eof_read ? EOF : 0; } /*there may be a bug here, when return 0.*/
    if((--n) <  -(_next - _start_buf)) {return 0;}
    return _next[n];
}

PUBLIC int ii_pushback(int n)
{
    while(--n >= 0 && _next > _smark){
        if(*--_next == '\n' || !*_next)
            --_lineno;
    }

    if(_next < _emark) {
        _emark = _next;
        _mline = _lineno;
    }

    return (_next > _smark);
}

/*'\0' terminated support. */
PUBLIC void ii_term(void)
{
    _termchar = *_next;
    *_next = '\0';
}

PUBLIC void ii_unterm(void)
{
    if(_termchar) {
        *_next = _termchar;
        _termchar = 0;
    }
}

PUBLIC int ii_input(void)
{
    int rval;

    if(_termchar) {
        ii_unterm();
        rval = ii_advance();
        ii_mark_end();
        ii_term();
    } else {
        rval = ii_advance();
        ii_mark_end();
    }

    return rval;
}

PUBLIC void ii_unput(int c)
{
    if(_termchar){
        ii_unterm();
        if(ii_pushback(1)) {
            *_next = c;
        }
        ii_term();
    }
    else {
        if(ii_pushback(1)){
            *_next = c;
        }
    }
}

PUBLIC int ii_lookahead(int n)
{
    return (n == 1 && _termchar) ? _termchar : ii_look(n);
}

PUBLIC int ii_flushbuf(void)
{
    if(_termchar) {ii_unterm();}
    return ii_flush(1);
}