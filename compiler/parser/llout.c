
/*---------------------------------------------*/

/*@A (C) 1992 Allen I. Holub                                                */

/*--------------------------------------------------------------
 *  Parser for llama-generated tables
 */

#include <stdio.h>
#include <string.h> 	  /* For strcat(), strlen() prototypes only.	   */
#include <stdlib.h>	      /* Needed only for prototype for exit(). Can be  */
			              /* discarded in most non-ANSI systems.	   */
#include <stdarg.h>
#include <l.h>

extern int	yylineno;     /* Supplied by LeX. */
extern int	yyleng;
extern char	*yytext;
extern int 	yylex();

void yy_code   (char *fmt, ...);
void yy_data   (char *fmt, ...);
void yy_bss    (char *fmt,...);
void yy_error  (char *fmt, ...);
void yy_comment(char *fmt, ...);
int  yy_next_token();



/*---------------------------------------------*/


#include <stdarg.h>
#include "acts.h"

#define CREATING_LLAMA_PARSER	/* Suppress various definitions in parser.h */
#include "parser.h"		        /* that conflict with llama-generated defs. */

/* This file is a llama input file that creates a parser for llama, like a snake
 * eating its tail. The resulting yyparse.c file can be used in place of the
 * recursive-descent parser in llpar.c. Note that, though this file is certainly
 * easier to write than the recursive-descent version, the resulting code is
 * about 1K larger. nows() should be called before firing up the parser.
 * Most of the external subroutines called from this module are in acts.c.
 * Exceptions are:
 */
extern char	*yytext;	/* Generated by lex	  */
extern int	yylineno;	/* Generated by lex	  */
extern void	nows(void);	/* Declared in llama.lex. */
extern void	ws(void);	/* Declared in llama.lex. */

#define YYSTYPE  char*	/* Value-stack type.	  */


/*-------------------------------------------*/

#include "llout.h"

#define YY_MINTERM     1
#define YY_MAXTERM     21
#define YY_MINNONTERM  256
#define YY_MAXNONTERM  268
#define YY_START_STATE 512

typedef unsigned char   YY_TTYPE;	/* Type used for tables. 	*/

#define YYF	(YY_TTYPE)( -1 )	    /* Failure transition in table. */

/*----------------------------------------------------------------------*/
#define YY_ISTERM(x)    (YY_MINTERM    <= (x) && (x) <= YY_MAXTERM   )
#define YY_ISNONTERM(x) (YY_MINNONTERM <= (x) && (x) <= YY_MAXNONTERM)
#define YY_ISACT(x)     (YY_MINACT     <= (x)                        )

#ifndef YYACCEPT
#    define YYACCEPT return(0)	/* Action taken when input is accepted.	     */
#endif

#ifndef YYABORT
#    define YYABORT return(1)	/* Action taken when input is rejected.	     */
#endif

#ifndef YYPRIVATE
#    define YYPRIVATE static	/* Define to a null string to make public.   */
#endif

#ifndef YYMAXERR
#    define YYMAXERR 25  	    /* Abort after this many errors.          */
#endif

#ifndef YYMAXDEPTH           	/* Parse- and value-stack depth.	  */
#    define YYMAXDEPTH 128
#endif

#ifndef YYSTYPE           	    /* Used to declare fields in value stack. */
#    define YYSTYPE int
#endif

int 	 yy_act( int actnum );  /* Supplied by llama */
YY_TTYPE yy_next( int cur_state, unsigned c );

/*----------------------------------------------------------------------
 * Parse and value stacks:
 */
#undef   yystk_cls
#define  yystk_cls YYPRIVATE
#undef   yystk_err
#define  yystk_err(o)  ((o) ? (yyerror("Stack overflow\n" ),exit(1)) \
			                : (yyerror("Stack underflow\n"),exit(1)) )

#define yytos(stk)  yystk_item(stk, 0) /* Evaluates to top-of-stack item.*/


yystk_dcl( Yy_stack, int, YYMAXDEPTH );

typedef struct			/* Typedef for value-stack elements. */
{
    YYSTYPE  left;		/* Holds value of left-hand side attribute.   */
    YYSTYPE  right;		/* Holds value of current-symbol's attribute. */

} yyvstype;

yyvstype  Yy_vstack[ YYMAXDEPTH ]; 		    /* Value stack.		*/
yyvstype *Yy_vsp = Yy_vstack + YYMAXDEPTH;	/* Value-stack pointer	*/



/*--------------------------------------------------------------
 * The YypNN arrays hold the right-hand sides of productions, listed back
 * to front (so that they are pushed in reverse order), NN is the production
 * number (to be found in the symbol-table listing output with a -s switch).
 * 
 * Yy_pushtab[] is indexed by production number and points to the appropriate
 * right-hand side (YypNN) array.
 */

YYPRIVATE int Yyp32[ ] = { 13, 0 };
YYPRIVATE int Yyp31[ ] = { 266, 9, 0 };
YYPRIVATE int Yyp21[ ] = { 0 };
YYPRIVATE int Yyp20[ ] = { 263, 530, 5, 0 };
YYPRIVATE int Yyp19[ ] = { 263, 529, 7, 0 };
YYPRIVATE int Yyp27[ ] = { 0 };
YYPRIVATE int Yyp26[ ] = { 258, 265, 0 };
YYPRIVATE int Yyp38[ ] = { 0 };
YYPRIVATE int Yyp37[ ] = { 267, 540, 4, 267, 539, 16, 0 };
YYPRIVATE int Yyp36[ ] = { 267, 538, 7, 11, 0 };
YYPRIVATE int Yyp35[ ] = { 267, 537, 1, 0 };
YYPRIVATE int Yyp34[ ] = { 267, 536, 5, 0 };
YYPRIVATE int Yyp33[ ] = { 267, 535, 7, 0 };
YYPRIVATE int Yyp18[ ] = { 0 };
YYPRIVATE int Yyp17[ ] = { 262, 528, 5, 0 };
YYPRIVATE int Yyp16[ ] = { 262, 527, 7, 0 };
YYPRIVATE int Yyp30[ ] = { 268, 267, 534, 0 };
YYPRIVATE int Yyp2 [ ] = { 0 };
YYPRIVATE int Yyp1 [ ] = { 14, 513, 0 };
YYPRIVATE int Yyp23[ ] = { 0 };
YYPRIVATE int Yyp22[ ] = { 264, 7, 0 };
YYPRIVATE int Yyp25[ ] = { 0 };
YYPRIVATE int Yyp24[ ] = { 260, 531, 7, 0 };
YYPRIVATE int Yyp29[ ] = { 266, 3, 533, 5, 0 };
YYPRIVATE int Yyp28[ ] = { 266, 3, 532, 7, 0 };
YYPRIVATE int Yyp12[ ] = { 0 };
YYPRIVATE int Yyp11[ ] = { 257, 264, 524, 15, 0 };
YYPRIVATE int Yyp10[ ] = { 257, 2, 0 };
YYPRIVATE int Yyp9 [ ] = { 257, 523, 263, 522, 8, 0 };
YYPRIVATE int Yyp8 [ ] = { 257, 521, 263, 520, 12, 0 };
YYPRIVATE int Yyp7 [ ] = { 257, 519, 263, 518, 6, 0 };
YYPRIVATE int Yyp6 [ ] = { 257, 517, 262, 516, 18, 0 };
YYPRIVATE int Yyp5 [ ] = { 257, 515, 261, 19, 0 };
YYPRIVATE int Yyp4 [ ] = { 257, 514, 1, 20, 0 };
YYPRIVATE int Yyp3 [ ] = { 257, 260, 17, 0 };
YYPRIVATE int Yyp0 [ ] = { 259, 258, 512, 14, 257, 0 };
YYPRIVATE int Yyp15[ ] = { 0 };
YYPRIVATE int Yyp14[ ] = { 261, 526, 5, 0 };
YYPRIVATE int Yyp13[ ] = { 261, 525, 7, 0 };
YYPRIVATE int *Yy_pushtab[ ] = 
{
	Yyp0 ,
	Yyp1 ,
	Yyp2 ,
	Yyp3 ,
	Yyp4 ,
	Yyp5 ,
	Yyp6 ,
	Yyp7 ,
	Yyp8 ,
	Yyp9 ,
	Yyp10,
	Yyp11,
	Yyp12,
	Yyp13,
	Yyp14,
	Yyp15,
	Yyp16,
	Yyp17,
	Yyp18,
	Yyp19,
	Yyp20,
	Yyp21,
	Yyp22,
	Yyp23,
	Yyp24,
	Yyp25,
	Yyp26,
	Yyp27,
	Yyp28,
	Yyp29,
	Yyp30,
	Yyp31,
	Yyp32,
	Yyp33,
	Yyp34,
	Yyp35,
	Yyp36,
	Yyp37,
	Yyp38
};

/*--------------------------------------------------------------
 * Yyd[][] is the DFA transition table for the parser. It is indexed as follows:
 * 
 *                   Input symbol
 *              +---------------------+
 *           L  |  production number  |
 *           H  |       or YYF        |
 *           S  |                     |
 *              +---------------------+
 * 
 * The production number is used as an index into Yy_pushtab, which looks like: 
 * 
 *           Yy_pushtab      YypDD:
 *           +--------+      +----------------+
 *           |   *----|----->|                |
 *           +--------+      +----------------+
 *           |   *----|----->
 *           +--------+
 *           |   *----|----->
 *           +--------+
 * 
 * YypDD is the tokenized right-hand side of the production.Generate a symbol
 * table listing with llama's -l command-line switch to get both production
 * numbers and the meanings of the YypDD string contents.
 */

YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ0 [] = {0,
                    -1,  -1,   0,  -1,  -1,  -1,   0,  -1,   0,  -1, 
                  -1,  -1,   0,  -1,   0,   0,  -1,   0,   0,   0, 
                   0,  -1};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ1 [] = {0,
                    -1,  -1,  10,  -1,  -1,  -1,   7,  -1,   9,  -1, 
                  -1,  -1,   8,  -1,  12,  11,  -1,   3,   6,   5, 
                   4,  -1};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ2 [] = { 4, 0,275,267,2614,27};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ3 [] = { 2, 0,214,1};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ4 [] = {0,
                    -1,  -1,  25,  -1,  -1,  -1,  25,  24,  25,  -1, 
                  -1,  -1,  25,  -1,  25,  25,  -1,  25,  25,  25, 
                  25,  -1};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ5 [] = {0,
                    -1,  -1,  15,  -1,  -1,  14,  15,  13,  15,  -1, 
                  -1,  -1,  15,  -1,  15,  15,  -1,  15,  15,  15, 
                  15,  -1};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ6 [] = {0,
                    -1,  -1,  18,  -1,  -1,  17,  18,  16,  18,  -1, 
                  -1,  -1,  18,  -1,  18,  18,  -1,  18,  18,  18, 
                  18,  -1};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ7 [] = {0,
                    -1,  -1,  21,  -1,  -1,  20,  21,  19,  21,  -1, 
                  -1,  -1,  21,  -1,  21,  21,  -1,  21,  21,  21, 
                  21,  -1};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ8 [] = {0,
                    -1,  -1,  23,  -1,  -1,  -1,  23,  22,  23,  -1, 
                  -1,  -1,  23,  -1,  23,  23,  -1,  23,  23,  23, 
                  23,  -1};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ9 [] = { 2, 5,297,28};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ10[] = {0,
                    -1,  30,  -1,  -1,  -1,  30,  -1,  30,  -1,  30, 
                  -1,  30,  -1,  30,  -1,  -1,  30,  -1,  -1,  -1, 
                  -1,  -1};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ11[] = {0,
                    -1,  35,  -1,  -1,  38,  34,  -1,  33,  -1,  38, 
                  -1,  36,  -1,  38,  -1,  -1,  37,  -1,  -1,  -1, 
                  -1,  -1};
YYPRIVATE YY_TTYPE ÿÿÿÿÿÿÿÿ12[] = { 2, 9,3113,32};

YYPRIVATE YY_TTYPE *ÿÿÿÿÿÿÿÿ[ 13 ] =
{
      ÿÿÿÿÿÿÿÿ0 ,    ÿÿÿÿÿÿÿÿ1 ,    ÿÿÿÿÿÿÿÿ2 ,    ÿÿÿÿÿÿÿÿ3 ,    ÿÿÿÿÿÿÿÿ4 ,    ÿÿÿÿÿÿÿÿ5 ,    ÿÿÿÿÿÿÿÿ6 ,    ÿÿÿÿÿÿÿÿ7 ,    ÿÿÿÿÿÿÿÿ8 ,    ÿÿÿÿÿÿÿÿ9 ,    
    ÿÿÿÿÿÿÿÿ10,    ÿÿÿÿÿÿÿÿ11,    ÿÿÿÿÿÿÿÿ12
};


/*-------------------------------------------------------*/
YYPRIVATE YY_TTYPE yy_next( cur_state, c )
unsigned int c;
int      cur_state;
{
    /* Given the current state and the current input character, return
     * the next state.
     */

    YY_TTYPE    *p = Yyd[ cur_state ] ;
    int i;

    if(p)
    {
        if((i = *p++) == 0)
            return p[ c ];

        for(; --i >= 0; p += 2)
            if(c == p[0])
                return p[1];
    }
    return YYF;
}



/*--------------------------------------------------------------
 * Yy_act() is the action subroutine. It is passed the tokenized value of
 * an action and executes the corresponding code.
 */

YYPRIVATE int yy_act(int actnum)
{
   /*The actions. Returns 0 normally but a nonzero error code can be returned
    *if one of the acts causes the parser to terminate abnormally.
    */

    switch(actum) {
        case 540:
		{
        break;
        case 527:
		{
        break;
        case 520:
		{
        break;
        case 528:
		{
        break;
        case 521:
		{
        break;
        case 532:
		{
        break;
        case 512:
		{
        break;
        case 529:
		{
        break;
        case 533:
		{
        break;
        case 513:
		{
        break;
        case 530:
		{
        break;
        case 534:
		{
        break;
        case 514:
		{
        break;
        case 531:
		{
        break;
        case 535:
		{
        break;
        case 522:
		{
        break;
        case 515:
		{
        break;
        case 536:
		{
        break;
        case 523:
		{
        break;
        case 516:
		{
        break;
        case 537:
		{
        break;
        case 524:
		{
        break;
        case 517:
		{
        break;
        case 538:
		{
        break;
        case 525:
		{
        break;
        case 518:
		{
        break;
        case 539:
		{
        break;
        case 526:
		{
        break;
        case 519:
		{
        break;
    default: printf("INTERNAL ERROR: Illegal action number (%s)\n",
                                                              actnum);
             break;
    }
    return 0;
}

/*--------------------------------------------------------------
 * Yy_synch[] is  an array of synchronization tokens. When an error is detected, 
 * stack items are popped until one of the tokens in this array is encountered.
 * The input is then read until the same item is found. Then parsing continues.
 */

YYPRIVATE int Yy_synch[] = 
{
	OR,
	SEMI,
	-1
};

/*--------------------------------------------------------------
 * Yy_stok[] is used for debugging and error messages.It is indexed by
 * the internal value used for a token(as used for a column index in the
 * transition matrix) and evaluates to a string naming that token.
 */

YYPRIVATE char *Yy_stok[] = 
{
	 /*  0  */    "_EOI_",
	/*   1 */    "ACTION",	/*   2 */    "CODE_BLOCK",
	/*   3 */    "COLON",	/*   4 */    "END_OPT",
	/*   5 */    "FIELD",	/*   6 */    "LEFT",
	/*   7 */    "NAME",	/*   8 */    "NONASSOC",
	/*   9 */    "OR",	/*  10 */    "OTHER",
	/*  11 */    "PREC",	/*  12 */    "RIGHT",
	/*  13 */    "SEMI",	/*  14 */    "SEPARATOR",
	/*  15 */    "START",	/*  16 */    "START_OPT",
	/*  17 */    "SYNCH",	/*  18 */    "TERM_SPEC",
	/*  19 */    "TYPE",	/*  20 */    "PERCENT_UNION",
	/*  21 */    "WHITESPACE"
};


 #ifdef YYDEBUG

/*--------------------------------------------------------------
 * Yy_snonterm[] is used only for debugging.It is indexed by the tokenized left-hand
 * side(as used for a row index in Yyd[]) and evaluates to a string naming that lhs.
 */

char *Yy_snonterm[] = 
{
	/* 256 */ "spec",
	/* 257 */ "defs",
	/* 258 */ "rules",
	/* 259 */ "end",
	/* 260 */ "snames",
	/* 261 */ "fnames",
	/* 262 */ "tnames",
	/* 263 */ "pnames",
	/* 264 */ "opt_names",
	/* 265 */ "rule",
	/* 266 */ "right_sides",
	/* 267 */ "rhs",
	/* 268 */ "end_rhs"
};


/*--------------------------------------------------------------
 * Yy_sact[] is alse used only for debugging. It is indexed by the internal value
 * used for an action symbol and evaluates to a string naming that token symbol.
 */

char *Yy_sact[] = 
{
	"{0}","{1}","{2}","{3}","{4}","{5}","{6}","{7}",
	"{8}","{9}","{10}","{11}","{12}","{13}","{14}","{15}","{16}","{17}",
	"{18}","{19}","{20}","{21}","{22}","{23}","{24}","{25}","{26}","{27}",
	"{28}" 
};

 #endif

/*----------------------------------------------------------------------*/

FILE  *yycodeout = NULL ;	/* Output stream for code. 		         */
FILE  *yybssout  = NULL ;	/* Output stream for initialized data. 	 */
FILE  *yydataout = NULL ;	/* Output stream for uninitialized data. */
int    yynerrs   = 0;		/* Error count.	 			             */

void yy_init_stream()
{
    yycodeout = stdout;
    yybssout  = stdout;
    yydataout = stdout;
}

/*----------------------------------------------------------------------*/
#ifdef YYDEBUG                  	/* Debugging parse stack. */

yystk_dcl( Yy_dstack, char *, YYMAXDEPTH );

YYPRIVATE char *yy_sym(int sym)
{
    /* Return a pointer to a string representing the symbol, using the
     * appropriate table to map the symbol to a string.
     */
    return ( YY_ISTERM( sym ) || !sym ) ?   Yy_stok[sym]:
           ( YY_ISNONTERM( sym )      ) ?   Yy_snonterm [sym - YY_MINNONTERM]:
           /* assume it's an act        */  Yy_sact     [sym - YY_MINACT] ;
}

/* Stack-maintenance. yy_push and yy_pop push and pop items from both the
 * parse and symbol stacks simultaneously. The yycomment calls in both routines
 * print a message to the comment window saying what just happened. The
 * yy_pstack() call refreshes the stack window and also requests a new command
 * from the user. That is, in most situations, yy_pstack() won't return until
 * the user has typed another command (exceptions are go mode, and so forth).
 * yy_pstack() also checks for break points and halts the parse if a breakpoint
 * condition is met.
 */
YYPRIVATE void yy_push(int x, YYSTYPE val)
{
    yypush ( Yy_stack,  x		);
    yypush_( Yy_dstack, yy_sym(x)	);

    --Yy_vsp;					              /* The push() macro checked */
    Yy_vsp->left = Yy_vsp->right = val;		  /* for overflow already.    */

    yy_comment( "push %s\n", yy_sym( x )  );
    yy_pstack( 0, 1 );
}

YYPRIVATE int yy_pop (void)
{
    int prev_tos = yypop( Yy_stack  );
    ++Yy_vsp;

    yy_comment( "pop %s\n", yypop_( Yy_dstack ) );
    yy_pstack ( 0, 1 );

    return prev_tos;
}

YYPRIVATE void yy_say_whats_happening(int tos_item, int production)
{
    /* Print a message in the comment window describing the replace operation
     * about to be performed. The main problem is that you must assemble a
     * string that represents the right-hand side of the indicated production.
     * I do this using the appropriate Yy_pushtab element, but go through the
     * array backwards (the Yy_pushtab arrays have been reversed to make the
     * production-mode parse more efficient--you need to unreverse them here).
     * Note that you can't just decrement end, comparing it with start in
     * the for loop that does the assembling. That is, this won't work:
     * 			while( --end >= start )
     * in the 8086 compact or large models because start might be at the
     * beginning of a segment. If it wraps past the start of the segement,
     * then end will never be less than start. Consequently, you need the
     * loop counter (nterms) to control the number of iterations.
     */

    char  buf[80];	     /* Assemble string representing right-hand side here.*/
    int	  count;         /* Maximum size of string representing RHS.	      */
    int   *start, *end;  /* Start and end of Yy_pushtab array that holds RHS. */
    int   nterms;	     /* Number of items to process in the production      */

    start = Yy_pushtab[ production ];
    for( end = start; *end; ++end )     /* After loop, end is positioned */
	;				                    /* to right of last valid symbol */

    count = sizeof(buf);
    *buf  = '\0';
    for(nterms = end - start; --nterms >= 0 && count > 0 ; ){ 	/* Assemble */
    								                            /* string.  */
	    strncat( buf, yy_sym(*--end), count );
	    if( (count -= strlen( yy_sym(*end) + 1 )) < 1 )
	        break;
	    strncat( buf, " ", --count );
    }
    yy_comment( "Applying %s->%s\n", yy_sym(tos_item), buf );
}

/* Use the following routines just like printf() to create output. In debug
 * mode, all three routines print to the output window (yy_output() is in
 * yydebug.c). In production mode, equivalent routines print to the associated
 * streams (yycodeout, yybssout, or yydataout). The first argument to
 * yy_output() tells the routine which stream is being used. If the stream is
 * still set to the default stdout, then the message is written only to the
 * window. If the stream has been changed, however, the output is sent both
 * to the window and the associated stream.
 */
void yy_code(char *fmt, ...) /* Write to the code-segment stream. */
{
    va_list   	 args;
    va_start( args,  fmt );
    yy_output( 0, fmt, args );
}

void yy_data(char *fmt, ...) /* Write to the data-segment stream. */
{
    va_list   	 args;
    va_start( args,  fmt );
    yy_output( 1, fmt, args );
}

void yy_bss(char *fmt, ...)  /* Write to the bss-segment stream.  */
{
    va_list   	 args;
    va_start( args,  fmt );
    yy_output( 2, fmt, args );
}

/* Debugging versions of yycomment() and yy_error() are pulled out of yydebug.c
 * when YYDEBUG is defined. Similarly, yy_break(), which halts the parse if a
 * break-on-production-applied breakpoint has been triggered, is found in
 * yydebug.c. It is eliminated from the production-mode output by defining it as
 * an empty macro, below. Finally, yy_nextoken(), which evaluates to a yylex()
 * call in production mode, and which is defined in yydebug.c, both gets the
 * next token and prints it in the TOKEN window.
 */
#else  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

#    define  yy_push(x,v)  	    ( yypush(Yy_stack, x),			    \
				                  --Yy_vsp, Yy_vsp->left=Yy_vsp->right=v )

#    define  yy_pop()    	    ( ++Yy_vsp, yypop(Yy_stack) )
#    define  yy_next_token()	yylex()
#    define  yy_quit_debug()
#    define  yy_sym()
#    define  yy_say_whats_happening(tos_item,prod)
#    define  yy_redraw_stack()
#    define  yy_pstack(refresh,print_it)
#    define  yy_break(x)

void yy_code(char *fmt, ...) /* Write to the code-segment stream. */
{
    va_list args;
    va_start( args,      fmt );
    vfprintf( yycodeout, fmt, args );
}

void yy_data(char *fmt, ...) /* Write to the data-segment stream. */
{
    va_list args;
    va_start( args,  fmt );
    vfprintf( yydataout, fmt, args );
}

void yy_bss(char *fmt, ...)  /* Write to the bss-segment stream.  */
{
    va_list args;
    va_start( args,  fmt );
    vfprintf( yybssout, fmt, args );
}

void yy_comment(char *fmt, ...)
{
    va_list args;
    va_start( args,   fmt );
    vfprintf( stdout, fmt, args );
}

void yy_error(char *fmt, ...)
{
    va_list   args;
    extern char *yytext;
    extern int  yylineno;

    va_start( args, fmt );
    fprintf ( stderr, "ERROR (line %d near %s): ", yylineno, yytext );
    vfprintf( stderr, fmt, args );
    fprintf ( stderr, "\n" );
}
#endif

/*------------------------------------------------------------
 *  ERROR RECOVERY:
 */

YYPRIVATE bool yy_in_synch( int sym )
{
    /*  Return 1 if sym is in the synchronization set defined in Yy_synch. */

    int *p ;

    for( p = Yy_synch; *p  &&  *p > 0 ; p++ )
        if( *p == sym )
             return true;
    return false;
}

YYPRIVATE int yy_synch( int lookahead )
{
   /* Recover from an error by trying to synchronize the input stream and the
    * stack. Return the next lookahead token or 0 if we can't recover. Yyparse()
    * terminates if none of the synchronization symbols are on the stack. The
    * following algorithm is used:
    *
    *  (1) Pop symbols off the stack until you find one in the synchronization
    *	   set.
    *  (2) If no such symbol is found, you can't recover from the error. Return
    *      an error condition.
    *  (3) Otherwise, advance the input symbol either until you find one that
    *      matches the stack symbol uncovered in (1) or you reach end of file.
    */

    int    tok;

    if( ++yynerrs > YYMAXERR )
        return 0;

    while( !yy_in_synch( tok = yytos( Yy_stack )) \
					&& !yystk_empty( Yy_stack ))	/* 1 */
	yy_pop();

    if( yystk_empty(Yy_stack) )						/* 2 */
        return 0;

    while( lookahead && lookahead != tok )		    /* 3 */
        lookahead = yy_nextoken();

    return lookahead;
}

/*---------------------------------------------------------------------
 * The actual parser. Returns 0 normally, -1 if it can't synchronize after an
 * error, otherwise returns a nonzero value returned by one of the actions.
 */
int yyparse(void)
{
    int      *p;		    /* General-purpose pointer.       	      */
    YY_TTYPE prod;		    /* Production being processed.    	      */
    int      lookahead;		/* Lookahead token.              	      */
    int	     errcode = 0;	/* Error code returned by an act. 	      */
    int	     tchar;		    /* Holds terminal character in yytext.	  */
    int	     actual_lineno;	/* Actual input line number.		      */
    char     *actual_text;	/* Text of current lexeme.		          */
    int	     actual_leng;	/* Length of current lexeme.		      */
    YYSTYPE  val;		    /* Holds $$ value for replaced nonterm.	  */

    yy_init_stream();

#   ifdef YYDEBUG
	if( !yy_init_debug( Yy_stack,  &yystk_p(Yy_stack),
			    Yy_dstack, &yystk_p(Yy_dstack),
			    Yy_vstack, sizeof(yyvstype), YYMAXDEPTH) )
	    YYABORT;

	yystk_clear(Yy_dstack);
#   endif

    yystk_clear(Yy_stack);
    Yy_vsp = Yy_vstack + YYMAXDEPTH;

    yy_push( YY_START_STATE, (Yy_vsp-1)->left );  /* Push start state onto parse stack and junk   */
						                          /* onto the value stack.                        */
    yy_init_llama( Yy_vsp );			          /* User-supplied init.                          */
    lookahead = yy_next_token();

    while( !yystk_empty(Yy_stack) ) {

        if( YY_ISACT( yytos(Yy_stack) ) ) {	      /* if TOS is an action,do it and pop the action.*/

	        if( yytext = (char *) ii_ptext() ) {
		        yylineno       = ii_plineno() ;
		        tchar          = yytext[ yyleng = ii_plength() ];
		        yytext[yyleng] = '\0' ;
	        } else {                          /* no previous token */
		        yytext = "";
		        yyleng = yylineno = 0;
	        }

	        if( errcode = yy_act( yytos(Yy_stack) ))
		        return errcode;

	        yy_pop();
	        yy_redraw_stack();
	        if( yylineno ) ii_ptext()[ ii_plength() ] = tchar;

	    } else if( YY_ISTERM( yytos(Yy_stack) )){	/* Advance if it's a terminal.*/

            if( yytos(Yy_stack) != lookahead ) {	/* ERROR if it's not there.   */
                yyerror( "%s expected\n", Yy_stok[ yytos(Yy_stack) ]);
                if( !(lookahead = yy_synch(lookahead)) )
	                YYABORT;

            } else {

                /* Pop the terminal symbol at top of stack. Mark the current
	             * token as the previous one (we'll use the previous one as
	             * yytext in subsequent actions), and advance.
                 */
                yy_pop();
                ii_mark_prev();

                lookahead     = yy_nextoken();
	            actual_lineno = yylineno;
	            actual_text   = yytext  ;
	            actual_leng   = yyleng  ;
            }
        } else {

	        /* Replace a nonterminal at top of stack with its right-hand side.
	         * First look up the production number in the table with the
	         * yy_next call. If prod==YYF, there was no legal transition and
	         * error-processing is activated. Otherwise the replace operation
	         * is done by popping the nonterminal, and pushing the right-hand
	         * side from the appropriate Yy_pushtab entry.
	         */

            prod = yy_next( yytos(Yy_stack)-YY_MINNONTERM, lookahead );

            if( prod == YYF ) {
                yyerror( "Unexpected %s\n", Yy_stok[ lookahead ] );
                if( !(lookahead = yy_synch(lookahead)) )
	                YYABORT;
            } else {
	            yy_say_whats_happening( yytos(Yy_stack), prod );
	            yy_break( prod );

	            val = Yy_vsp->right ;
                yy_pop();

                for( p = Yy_pushtab[ prod ] ; *p ; ++p )
                    yy_push( *p, val );
            }
        }
    }

    yylineno = actual_lineno ;	 /* Make these hold reasonable values in case */
    yytext   = actual_text   ;   /* the remainder of the input file must be   */
    yyleng   = actual_leng   ;   /* processed further.			              */

    yy_quit_debug();
    YYACCEPT;
}
